=pod

=head1 NAME

WGmeta::IPmanager - Class for managing IPv4 address ranges

=head1 SYNOPSIS

    use Wireguard::WGmeta::IPmanager;
    my $ranges = {
        #IPv6 entries are ignored
        'target_1' => extract_ipv4('10.0.0.2/24,fdc9:281f:04d7:9ee9::2/64,80.0.0.2/24'),
        'target_2' => extract_ipv4('192.168.0.1/28,fdc9:281f:04d7:9ee9::2/64,90.0.0.2/32')
    };

    my $ip = Wireguard::WGmeta::IPmanager->new();
    $ip->ipv4_build_database($ranges);
    $ip->ipv4_acquire('90.0.0.2', 'target_2');

    $ip->ipv4_suggest('target_2', 2);

=head1 DESCRIPTION

Simple IPv4-ranges manager with abilities to acquire and release addresses.

=head1 METHODS

=cut

package Wireguard::WGmeta::IPmanager;
use strict;
use warnings FATAL => 'all';
use experimental 'signatures';

use base 'Exporter';
our @EXPORT = qw(extract_ipv4 get_ip_list);

use constant MAX_SUBNET_SIZE => 22;

sub new($class) {
    my $self = {
        'ip_database'  => {},
        'ip_meta_info' => {}
    };
    bless $self, $class;
    return $self;
}

=head3 ipv4_build_database($ref_ip_list)

Builds the internal ip database. The C<$ref_ip_list> is expected to have to following structure:

    {
        'target_name1' => [[<network_id>, <subnet_size>], [<network_id>, <subnet_size>],...],
        'target_name2' => [[<network_id>, <subnet_size>], [<network_id>, <subnet_size>],...]
    }

Such a structure can be generated by supplying a string of comma-separated ips to L</extract_ipv4($ip_string)>

B<Parameters>

=over 1

=item

C<$ref_ip_list> A list with ipv4_networks - as described above

=back

B<Returns>

A reference to hash which enumerates all possible ips for a subnet/target

    {
        'target_1' => {
            '10.0.0.1' => 1,
            '10.0.0.2' => 1,
            ...
        },
        'target_1 => {
            '10.0.2.1' => 1,
            '10.0.2.2' => 1,
            ...
        },
        ...
    }

=cut
sub ipv4_build_database($self, $ref_ip_list) {
    my $ip_database = $self->{ip_database};
    my $ip_meta_info = $self->{ip_meta_info};
    for my $target_name (keys %{$ref_ip_list}) {
        my $ip_target_database = {};
        my $n_ips_for_target = 0;
        for my $networks (@{$ref_ip_list->{$target_name}}) {
            my ($network, $subnet_size) = @{$networks};

            if ($subnet_size < MAX_SUBNET_SIZE) {
                warn "Subnet size ($subnet_size) is larger than MAX_SUBNET_SIZE, skipping $target_name";
                next;
            }
            if (defined $network) {
                my (undef, $n_ips) = _generate_ipv4_list($network, $subnet_size, $ip_target_database);
                $n_ips_for_target += $n_ips;
            }
        }
        $ip_database->{$target_name} = $ip_target_database;
        $ip_meta_info->{$target_name}{n_ips} = $n_ips_for_target;
    }
}

=head3 ipv4_acquire($ipv4, $target_name)

Tries to acquire one ip from a target.

B<Parameters>

=over 1

=item

C<$ipv4> An ip address as string e.g I<10.0.30.56>

=item

C<$target_name> A target name

=back

B<Returns>

Returns 1 on success, undef on failure

=cut
sub ipv4_acquire($self, $ipv4, $target_name) {
    chomp $ipv4;
    if (exists $self->{ip_database}{$target_name} && $self->{ip_database}{$target_name}{$ipv4}) {
        delete $self->{ip_database}{$target_name}{$ipv4};
        $self->{ip_meta_info}{$target_name}{n_ips}--;
        return 1;
    }
    else {
        return undef;
    }
}

=head3 ipv4_release($ipv4, $target_name)

Tries to acquire one ip from a target.

B<Caveat:> Due tue they way this utility is implemented, this function basically adds C<$ipv4> to list
of available ips, regardless of the fact that it may not fit in the sourcing subnet.

B<Parameters>

=over 1

=item

C<$ipv4> An ip address as string e.g I<10.0.30.56>

=item

C<$target_name> A target name

=back

B<Returns>

Returns 1 on success, undef on failure.

=cut
sub ipv4_release($self, $ipv4, $target_name) {
    if (exists $self->{ip_database}{$target_name}) {
        $self->{ip_database}{$target_name}{$ipv4} = 1;
        $self->{ip_meta_info}{$target_name}{n_ips}++;
        return 1;
    }
    else {
        return undef;
    }
}

sub ipv4_suggest($self, $target_name, $n = 1) {
    if (exists $self->{ip_database}{$target_name} && $self->{ip_meta_info}{$target_name}{n_ips} > 0) {
        $n = $self->{ip_meta_info}{$target_name}{n_ips} - 1 if $n >= $self->{ip_meta_info}{$target_name}{n_ips};
        my @free_ips = keys %{$self->{ip_database}{$target_name}};
        return @free_ips[0 .. $n];
    }
    else {
        return ();
    }
}


sub _generate_ipv4_list($network_id, $subnet_size, $ref_ip_database) {
    # thanks to https://www.perl.com/article/creating-ip-address-tools-from-scratch/

    my $n_ips = 0;
    my @bytes = split /\./, $network_id;
    my @ips;
    my $start_decimal = $bytes[0] * 2 ** 24 + $bytes[1] * 2 ** 16 + $bytes[2] * 2 ** 8 + $bytes[3];
    my $bits_remaining = 32 - $subnet_size;
    my $end_decimal = $start_decimal + 2 ** $bits_remaining - 1;

    # # exclude network_id & broadcast address
    # if ($subnet_size < 31) {
    #     $start_decimal += 1;
    #     $end_decimal -= 1;
    # }
    while ($start_decimal <= $end_decimal) {
        my @bytes = unpack 'CCCC', pack 'N', $start_decimal;
        my $ipv4 = (join '.', @bytes);
        $ref_ip_database->{$ipv4} = 1;
        push @ips, $ipv4;
        $start_decimal++;
        $n_ips++;
    }
    return \@ips, $n_ips;
}

sub get_ip_list($network_id, $subnet_size) {
    my ($ref_ips, $n_ips) = _generate_ipv4_list($network_id, $subnet_size, {});
    return $ref_ips;
}

=head3 extract_ipv4($ip_string)

Takes a comma-separated and extracts
the B<ipv4> network and subnet part.

B<Parameters>

=over 1

=item

C<$ip_string> String containing ip addresses (v4 & v6): e.g I<'192.168.0.1/28,fdc9:281f:04d7:9ee9::2/64,90.0.0.2/32'>

=back

B<Returns>

Reference to list with the following structure:

    [
        [<network_id>, <subnet_size>],
        [<network_id>, <subnet_size>],
        ...
    ]

Invalid blocks are skipped silently

=cut
sub extract_ipv4($ip_string) {
    my @ips = split /\,/, $ip_string;
    chomp(@ips);
    my @result;
    for my $possible_ip (@ips) {
        my @a = $possible_ip =~ /(^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/(\d{1,2})/g;
        push @result, [ $a[0], $a[1] ] if @a;
    }
    return \@result;
}

1;